#!/usr/bin/env python3

import rospy
from std_msgs.msg import Float32

class ComplementaryFilter:
    def __init__(self):
        # Frecuencia de muestreo
        self.dt = 0.1

        # Ganancia del filtro complementario
        self.alpha = 0.98

        # Velocidad medida por el primer sensor
        self.vel1 = 0.0

        # Velocidad medida por el segundo sensor
        self.vel2 = 0.0

        # Velocidad filtrada
        self.vel_filtrada = 0.0

        # Subscriptores a los tópicos de velocidad
        rospy.Subscriber("/gps_speed", Float32, self.vel1_callback)
        rospy.Subscriber("/imu_speed", Float32, self.vel2_callback)

        # Publicador de la velocidad filtrada
        self.vel_filtrada_pub = rospy.Publisher("speed_filtered", Float32, queue_size=10)

    def vel1_callback(self, data):
        # Actualiza la velocidad medida por el primer sensor
        self.vel1 = data.data
        self.vel_filtrada = (self.vel_filtrada + self.vel1 * self.dt)


    def vel2_callback(self, data):
        # Actualiza la velocidad medida por el segundo sensor
        self.vel2 = data.data
        self.vel_filtrada = self.alpha * (self.vel_filtrada + self.vel1 * self.dt) + (1 - self.alpha) * self.vel2


    def run(self):
        # Bucle principal
        while not rospy.is_shutdown():
            # Combina las medidas de velocidad con el filtro complementario
            #self.vel_filtrada = self.alpha * (self.vel_filtrada + self.vel1 * self.dt) + (1 - self.alpha) * self.vel2

            # Publica la velocidad filtrada
            self.vel_filtrada_pub.publish(self.vel_filtrada)

            # Espera para mantener la frecuencia de muestreo
            rospy.sleep(self.dt)

if __name__ == '__main__':
    # Inicializa el nodo ROS
    rospy.init_node('complementary_filter')

    # Crea un objeto ComplementaryFilter
    cf = ComplementaryFilter()

    # Ejecuta el filtro complementario
    cf.run()

    # Para la ejecución del nodo ROS
    rospy.spin()